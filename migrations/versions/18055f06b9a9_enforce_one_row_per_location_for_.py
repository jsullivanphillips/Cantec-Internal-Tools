"""enforce one row per location for service_recurrence

Revision ID: 18055f06b9a9
Revises: cc662fc5848e
Create Date: 2025-09-09 08:39:59.712044

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '18055f06b9a9'
down_revision = 'cc662fc5848e'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    # 1) Keep newest row per location_id
    op.execute("""
    WITH ranked AS (
      SELECT id,
             ROW_NUMBER() OVER (
               PARTITION BY location_id
               ORDER BY updated_on_st DESC NULLS LAST, id DESC
             ) AS rn
      FROM service_recurrence
    )
    DELETE FROM service_recurrence sr
    USING ranked r
    WHERE sr.id = r.id AND r.rn > 1;
    """)

    op.create_unique_constraint(
        "uq_sr_one_per_location",
        "service_recurrence",
        ["location_id"],
    )

    # 3) (Optional) drop is_current column & its index if you won't use it anymore
    op.drop_index('ix_service_recurrence_is_current', table_name='service_recurrence')
    op.drop_column('service_recurrence', 'is_current')

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint("uq_sr_one_per_location", "service_recurrence", type_="unique")

    # You generally can't resurrect deleted duplicates; note that in your migration message.
    # (Optional) re-add is_current if you dropped it:
    op.add_column('service_recurrence', sa.Column('is_current', sa.Boolean(), nullable=True))
    op.create_index('ix_service_recurrence_is_current', 'service_recurrence', ['is_current'])

    # ### end Alembic commands ###
